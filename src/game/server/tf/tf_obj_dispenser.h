//========= Copyright © 1996-2005, Valve Corporation, All rights reserved. ============//
//
// Purpose: Engineer's Dispenser
//
// $NoKeywords: $
//=============================================================================//

#ifndef TF_OBJ_DISPENSER_H
#define TF_OBJ_DISPENSER_H
#ifdef _WIN32
#pragma once
#endif

#include "tf_obj.h"

class CTFPlayer;

#define DISPENSER_MAX_HEALTH	150

// ------------------------------------------------------------------------ //
// Resupply object that's built by the player
// ------------------------------------------------------------------------ //
class CObjectDispenser : public CBaseObject
{
	DECLARE_CLASS( CObjectDispenser, CBaseObject );

public:
	DECLARE_SERVERCLASS();

	CObjectDispenser();
	~CObjectDispenser();

	static CObjectDispenser* Create(const Vector &vOrigin, const QAngle &vAngles);

	virtual void	Spawn();
	virtual void	FirstSpawn( void ) OVERRIDE;
	virtual void	GetControlPanelInfo( int nPanelIndex, const char *&pPanelName );
	virtual void	Precache();
	virtual bool	ClientCommand( CTFPlayer *pPlayer, const CCommand &args );

	virtual void	DetonateObject( void );
	virtual void	DestroyObject( void ) OVERRIDE;
	virtual void	OnGoActive( void );	
	virtual bool	StartBuilding( CBaseEntity *pBuilder );
	virtual int		DrawDebugTextOverlays(void) ;
	virtual void	SetModel( const char *pModel );

	virtual const char* GetBuildingModel( int iLevel );
	virtual const char* GetFinishedModel( int iLevel );
	virtual bool	IsUpgrading( void ) const OVERRIDE { return (m_iState == DISPENSER_STATE_UPGRADING); }
	virtual void	StartUpgrading( void ) OVERRIDE;
	virtual void	FinishUpgrading( void ) OVERRIDE;

	virtual int		GetAvailableMetal( void ) const;

	void RefillThink( void );
	void DispenseThink( void );

	virtual void StartTouch( CBaseEntity *pOther );
	virtual void EndTouch( CBaseEntity *pOther );

	virtual int	ObjectCaps( void ) { return (BaseClass::ObjectCaps() | FCAP_IMPULSE_USE); }

	bool DispenseAmmo( CTFPlayer *pPlayer );

	void StartHealing( CBaseEntity *pOther );
	void StopHealing( CBaseEntity *pOther );

	void AddHealingTarget( CBaseEntity *pOther );
	void RemoveHealingTarget( CBaseEntity *pOther );
	bool IsHealingTarget( CBaseEntity *pTarget );

	bool CouldHealTarget( CBaseEntity *pTarget );

	Vector GetHealOrigin( void );

	CUtlVector< EHANDLE >	m_hHealingTargets;

	virtual void	MakeCarriedObject( CTFPlayer* pCarrier );

	virtual int		GetBaseHealth( void ) { return DISPENSER_MAX_HEALTH; }

protected:
	bool m_bUseGenerateMetalSound;

	CNetworkVar( int, m_iState );
	CNetworkVar( int, m_iAmmoMetal );

private:
	void ResetHealingTargets( void );

	//CNetworkArray( EHANDLE, m_hHealingTargets, MAX_DISPENSER_HEALING_TARGETS );

	// Entities currently being touched by this trigger
	CUtlVector< EHANDLE >	m_hTouchingEntities;

	float m_flNextAmmoDispense;

	string_t m_iszCustomTouchTrigger;
	EHANDLE m_hTouchTrigger;

	DECLARE_DATADESC();
};

inline int CObjectDispenser::GetAvailableMetal( void ) const
{
	return m_iAmmoMetal;
}


//------------------------------------------------------------------------------
class CObjectCartDispenser : public CObjectDispenser
{
	DECLARE_CLASS( CObjectCartDispenser, CObjectDispenser );

public:
	DECLARE_SERVERCLASS();
	DECLARE_DATADESC();

	CObjectCartDispenser();

	virtual void Spawn( void );
	virtual void OnGoActive( void );
	virtual void GetControlPanelInfo( int nPanelIndex, const char*& pPanelName );

	virtual int	DispenseMetal( CTFPlayer* pPlayer );

	virtual bool	CanBeUpgraded( CTFPlayer* pPlayer ) { return false; }
	virtual void	SetModel( const char* pModel );

	void InputSetDispenserLevel( inputdata_t& inputdata );
	void InputEnable( inputdata_t& inputdata );
	void InputDisable( inputdata_t& inputdata );
};
#endif // TF_OBJ_DISPENSER_H
